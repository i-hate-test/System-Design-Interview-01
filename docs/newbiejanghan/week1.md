# 처리율 제한 장치의 설계
> 고려 요소
> 1. 알고리즘
> 2. 미들웨어는 어디에?
> 3. 한도 초과된 요청의 응답 처리
> 4. 처리율 제한 규칙을 어떻게 반영하는가
> 5. 분산 환경

## 처리율 제한 알고리즘
### 토큰 버킷 알고리즘
- 토큰 버킷은 일정량의 토큰을 가지고 있는 컨테이너. 토큰 충전 규칙에 따라 리필됨.
- 버킷 크기, 토큰 공급률를 인자로 가짐.
- 공급 제한 규칙에 따라 사용자의 버킷 갯수가 달라질 수 있다. 
  엔드포인트 당 둘 것인지, IP 당 둘 것인지 또는 시스템 전체적으로 처리율을 유지한다면 버킷은 시스템에 하나만 존재해야할 것.
- **장점**: 구현이 쉽고 메모리 효율이 좋아보인다. 짧은 시간 트래픽 집중도 처리 가능
- **단점**: 인자가 적어 튜닝이 어렵다.

### 누출 버킷 알고리즘
- 토큰 버킷 알고리즘과 비슷하지만, 토큰을 자동 충전하는 컨테이너 역할의 버킷 대신, 요청을 보관하는 큐가 존재.
- 큐는 사이즈와 처리율을 인자로 가진다.
- **장점**: 큐의 크기 제한으로 메모리를 효율적으로 사용한다. 고정된 처리율로 안정된 출력이 필요한 경우 적합하다.
- **단점**: 단기간 트래픽의 경우 오래된 요청이 쌓여 최신 요청이 버려지는 문제. 인자가 적어 튜닝이 어렵다.

### 고정 윈도 카운터 알고리즘
- 전체 시간(Timeline)을 특정 구간(Window)으로 나누어 구간 당 요청을 카운팅하여 제한하는 방식.
- 윈도 크기와 윈도 내 요청 수를 인자로 가진다.
- **장점**: 메모리 효율, 이해도
- **단점**: 윈도 경계에 트래픽 몰리는 경우 기대한 처리 한도보다 많은 양을 처리할 수 있음.

### 이동 윈도 로깅 알고리즘
- 고정 윈도 카운터 알고리즘의 단점을 해결
- 요청의 타임스탬프를 추적하여 특정 구간 동안의 요청을 제한한다.
- **장점**: 윈도 경계에 트래픽 몰리는 문제를 해결. 아주 정교한 처리율 제한
- **단점**: 심지어 거부된 요청의 타임스탬프도 저장하기 때문에 메모리 사용량이 높다.

### 이동 윈도 카운터 알고리즘
- 고정 윈도 카운터 + 이동 윈도 카운터
- 구현 방법 중 하나로, 이동 윈도와 직전 1분이 겹치는 비율을 반영하는 방법.

## 미들웨어를 무엇으로 구현할까?
1. API Gateway
    > Amazon API Gateway
    > https://docs.aws.amazon.com/ko_kr/apigateway/latest/developerguide/api-gateway-request-throttling.html
    > 1. 토큰 버킷 알고리즘 사용
    > 2. SDK 또는 GUI 에서 설정 변경 가능
2. Application
- Java: spring-cloud-gateway https://spring.io/projects/spring-cloud-gateway

## 규칙 구현 - 설정 파일 (Configuration)
- 디스크에 저장, 설정 파일의 수정을 어떻게 할 지 추가적으로 생각해보면 좋음
- 디스크 I/O 성능을 고려하여 Cache 레이어에 올리고
- Batch, Schedule 등으로 디스크의 설정 파일을 읽고 Cache 에 미리 Write 하는 방식

## 분산 환경
### Race Condition 대응
- Lock => 성능 이슈
1. Lua script
별도의 참고 문서(https://medium.com/@Games24x7Tech/running-atomicity-consistency-use-case-at-scale-using-lua-scripts-in-redis-372ebc23b58e)에 따르면  
Redis 의 Lua script 를 이용하여 Atomic 한 트랜잭션을 구현할 수 있다고 함.  
Lua script 의 장점으로 서버에 스크립트를 내장하여 실행 속도가 빠르다는 것임.  
스크립트의 로직은 모르겠지만, 카운터 로직을 구현하여 실행하면 Atomicity 가 보장된 상태에서 카운팅되므로 Race Condition 의 동기화 문제를 해결할 수 있음.
2. Sorted Set
왜 굳이 Set 도 아닌 Sorted Set 을 제안한 지는 모르겠음.  
책의 참고 문헌 (https://engineering.classdojo.com/blog/2015/02/06/rolling-rate-limiter/)은  
Redis 의 Atomic 한 트랜잭션을 이용하여 Race Condition 문제에 대응하고 있음.


### 동기화 이슈
> 대용량 트래픽을 지원하려면 처리율 제한 장치 역시 여러대가 필요함
1. 고정 세션(Sticky session): 확장성, 유연성이 떨어짐. Why? 
2. 중앙 집중형 데이터 저장소: 카운터 관련 데이터를 한 군데에서 저장하는 방법. 대표적으로 레디스를 사용.


## 한도 초과된 응답
### HTTP Response
- 429 Too Many Requests
- X-Ratelimit-Remaining: 남은 요청 횟수
- X-Ratelimit-Limit: 최대 요청 횟수
- X-Ratelimit-Retry-After: 다음 리셋 시간

## 성능 최적화
### 에지 서버 지원 여부
데이터 센터로와의 물리적 거리로 인한 지연을 줄이기 위해 에지 서버를 사용할 수 있다.
### 최종 일관성 모델 Eventual Consistency Model


## 모니터링으로 무엇을 볼 것인가
- 처리율 제한 알고리즘의 효과: 이번트 오픈으로 트래픽 급증 시엔 토큰 버킷 알고리즘이 적합할 것
- 처리율 제한 규칙의 효과: 규칙이 너무 타이트하면 많은 유효 요청이 버려질 것 

## 추가로
### Hard Late Limit / Soft Late Limit
### 다른 OSI 계층에서의 처리율 제한
- Iptables: 3번 네트워크 계층에서의 제한
### 클라이언트가 처리율 제한을 회피하는 방법
- 예외, 에러 처리
- 충분한 백오프 시간을 가진 재시도 로직

---

- 구글 API는 어떤 식으로 처리하고 있을까?
- 처리율 제한 오픈소스 탐구
- 알고리즘 변경에 따른 코드, 시스템 변경을 최소화하는 아키텍처

