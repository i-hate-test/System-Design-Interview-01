# Bloom Filter

~~~~
원소가 집합에 속하는지 여부를 검사하는데 사용되는 확률적 자료 구조
~~~~

### Bit Array

중복되지 않는 정수 집합을 비트로 나타내는 방식

| 정수  | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|-----|---|---|---|---|---|---|---|
| bit | 0 | 1 | 0 | 0 | 1 | 0 | 0 |

[ 1, 4 ] 를 가지고 있는 bit array. 원소의 존재 유무룰 0, 1 bit 로 표현

### 확률적 자료 구조

~~~~
m 비트 크기의 구조 (Bit Array)
k 가지의 서로 다른 해시 함수
n 개의 원소
~~~~

**해시 함수**  
해시 함수는 m 가지의 값을 균등한 확률로 출력해야 한다.  
해시 함수의 성능이 블룸 필터의 성능과 직결된다. 대체로 murmur, md5, fnv 등이 사용된다.

**저장**  
k 개의 해시 함수를 적용하여 나온 k개의 값을 각각 비트에 저장.

**조회**  
조회할 값에 대해 k개의 해시 함수를 적용하여 나온 k개의 값이 모두 1이면 원소가 존재한다고 판단.

### 성질

~~~~
긍정 오류(False Positive): 원소가 집합에 없지만 있다고 판단하는 오류
부정 오류(False Negative): 원소가 집합에 있지만 없다고 판단하는 오류
~~~~

**해시 충돌**  
해시 함수의 성질에 따라 해시 충돌이 발생할 수 있다.   
해시 충돌이란 원래 값이 다른데 해시 함수를 적용한 결과가 같은 경우를 말한다.

**오류**   
해시 충돌 상황의 경우, 집합에 원소가 포함되어 있지 않지만 포함되어 있다고 판단할 수 있다. => 긍정 오류 발생  
반면 값이 같은데 해시 결과가 달라지는 경우는 없다. => 부정 오류 발생하지 않음

**efficiency**

- O(k) 시간 복잡도

**trade-off**

- k가 증가할수록 필터의 속도가 느려지고, 더 빨리 자료 구조가 채워진다.
- k가 감소할수록 더 많은 긍정 오류가 발생한다.
- 적합한 k를 계산하는 수식: k = m/n * ln(2)

### 활용

- 긍정 오류율을 최적화하여, 대용량 데이터 처리 중 필터링 역할
    - 예를 들어 카톡 소셜 로그인 유저의 이용 로그를 필터링 하는 케이스.
    - 카톡 소셜 로그인 유저 id 로 필터를 만든 다음, 이용 로그의 id 값을 필터에 조회하여 1차적 필터링.
    - 긍정 오류가 발생한다면 카톡 이외의 소셜로그인 유저의 이용 로그가 아직 존재하는 경우는 발생할 수 있음.
    - 하지만 카톡 유저의 로그가 배제되는 경우는 없음.
    - 이런 필터링을 통해 join 연산 대상을 현저하게 줄이는 방법이 가능.
- 빠른 조회 성능으로 특정 값이 이미 db에 존재하는지를 확인하는 기능
    - ex. 이 닉네임이 이미 존재하는지 확인하는 기능
    - 특히 cache 에서 사용하면 더 효과적일 수 있음.
    - 이미 redis 는 bloom filter 를 지원한다.

---

### Reference

- https://llimllib.github.io/bloomfilter-tutorial/
- https://meetup.nhncloud.com/posts/192
- https://redis.io/docs/latest/develop/data-types/probabilistic/bloom-filter/